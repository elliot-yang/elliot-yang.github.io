{"meta":{"title":"Yang's Blog","subtitle":null,"description":null,"author":"Yang","url":"https://elliot-yang.github.io"},"pages":[{"title":"关于我","date":"2018-06-13T16:46:51.000Z","updated":"2020-10-22T12:07:25.560Z","comments":true,"path":"about/index.html","permalink":"https://elliot-yang.github.io/about/index.html","excerpt":"","text":"杨扬 男 / 1995年 三年工作经验 所在地：上海 学历：本科（全日制） 手机：+86-15579151664 邮箱：elliot-yang@outlook.com 工作经历**信息 中台项目研发 项目简介：中台项目是为了方便APP调用老业务系统及新系统接口而产生的，主要是能够保证在业务系统内网隔离的情况下，APP能从外网访问业务系统的数据。 参与内容： 集成Oauth2以及JWT等认证方式 提供接口转发（一般是App请求到中台，然后中台访问业务系统），同时记录进出站日志。 提供接口请求及响应数据的转换功能 添加微信模块，支持对微信公众号进行菜单管理、客服消息发送、自动回复等。 **信息 **易项目研发 项目简介：**易系统是为**行业量身打造的业务系统，能够信息化整个业务流程，方便行业公司对内部业务数据的管理。 参与内容： RabbitMQ队列支持，可用于与其他系统进行数据交换。 合同文本生成功能，通过预设word模板（docx），可通过传递参数添加图片或文字水印、生成表格、动态添加表格行、生成段落内容、任意书签替换等。 通过MyBatis拦截器和正则表达式实现系统原有SQL，兼容MySQL和Oracle。 通过MyBatis拦截器实现敏感数据过滤器及白名单。 通过拦截器和LogBack完成日志按照用户及uri分配到不同日志文件。 通过拦截器完成对老系统的接口结果数据兼容。 支持服务端运行JavaScript代码，并支持调用Java代码以及获取spring托管的bean，实现服务端部分功能热部署。 数据动态修改，通过传递Map和tableName，自动解析当前数据库中对应表结构，可执行CRUD等操作。 其他业务相关功能模块。 主要技能 编程语言：主要使用Java，能使用python、C#等写小工具辅助工作 框架：Spring，SpringMVC，Spring Boot，Spring Boot 数据库：常用MySQL和Oracle 版本管理：SVN、GIT 熟悉Linux基本操作，能部署大部分软件，并掌握基本的Linux上对Java服务监控技能"}],"posts":[{"title":"重学设计模式之单例模式","slug":"singleton","date":"2020-10-20T13:03:37.000Z","updated":"2020-10-22T12:07:25.560Z","comments":true,"path":"2020/10/20/singleton/","link":"","permalink":"https://elliot-yang.github.io/2020/10/20/singleton/","excerpt":"前言最近觉得自己基础虚浮, 准备重新学习基础知识, 设计模式中的单例模式又是非常常用的模式, 所以先从单例模式开始.","text":"前言最近觉得自己基础虚浮, 准备重新学习基础知识, 设计模式中的单例模式又是非常常用的模式, 所以先从单例模式开始. 单例模式介绍单例模式（Singleton Pattern）是GOF23种设计模式中的创建型模式中的一种, 也是最简单的模式之一。它提供了一种创建对象的方法，同时保证有且仅有一个该对象被创建，并提供获取该对唯一对象的入口。 实现由于使用场景很多，单例模式也有多种不同的实现，常见的有6种： 懒汉式懒汉式的实现最为简单，且只有在对象被使用到时才会进行对象的创建，所以被称为懒汉式。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class SingleObject&#123; private static singleObject; private Singleton ()&#123;&#125; public static SingleObject getInstance()&#123; if(singleObject == null)&#123; singleObject = new SingleObject(); &#125; return singleObject; &#125; //...&#125;``` 从上面的代码可以看出，懒汉式的实现十分简单， 但缺点也十分明显，就是存在线程不安全的问题。当多个线程并发调用`getInstance()`方法时，SingleObject可能会被创建多次。 所以为了改进， 又有一种线程安全的懒汉式实现 ### 懒汉式（线程安全）鉴于普通懒汉式线程安全问题，很容易想到使用锁来解决问题。于是便有下面的代码 ```javapublic class SingleObject&#123; private static singleObject; private Singleton ()&#123;&#125; public static synchronized SingleObject getInstance()&#123; if(singleObject == null)&#123; singleObject = new SingleObject(); &#125; return singleObject; &#125; //...&#125;``` 仅仅在方法上添加了一个`synchronized`关键字，让整个方法进入时需要获取对象锁。该方法的优势在于锁简单，但在高并发情况过重的锁会引起性能问题。所以再次基础上又有一种改进的方法。 ### 懒汉式（双重检查）过重的锁在并发誓有性能问题，所以可以考虑缩小锁的范围。 ```javapublic class SingleObject&#123; private volatile static singleObject; private Singleton ()&#123;&#125; public static SingleObject getInstance()&#123; if(singleObject == null)&#123; synchronized(SingleObject.class)&#123; if(singleObject == null)&#123; singleObject = new SingleObject(); &#125; &#125; &#125; return singleObject; &#125; //...&#125; ``` 之所以要对`singleObject`两次判空操作，是为了防止在获取到锁之前， 别的线程已经完成了该对象的初始化， 防止重复创建。同事还需要对`singleObject`对象加上`volatile`修饰符，是为了保证该对象在内存重的可见性，防止编译重排导致逻辑不正确。 ### 静态内部类双重检查这种方式既保障了对象只能创建一次，又保障了在并发时的性能，是一种非常好用的方式。 另外也可以通过静态内部类的特性来实现双重检查一样的效果。 ```javapublic class Singleton &#123; private static class ObjectHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return ObjectHolder.INSTANCE; &#125; &#125;``` ### 枚举枚举也是能够实现单例的途径之一，但是目前看到出现的频率比较低。 枚举也能只能序列化，也能保证对象只创建一次，而且写法简单的同时还保证了线程安全。 ```java public enum Singleton &#123; INSTANCE; public void doSomething() &#123; &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://elliot-yang.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://elliot-yang.github.io/tags/设计模式/"}]},{"title":"vscode快速粘贴图片为markdown形式","slug":"vscode","date":"2020-10-15T16:08:23.000Z","updated":"2020-10-22T12:07:25.560Z","comments":true,"path":"2020/10/15/vscode/","link":"","permalink":"https://elliot-yang.github.io/2020/10/15/vscode/","excerpt":"最近开始回归github pages, 重新捡起VS CODE来写记录了. 工欲善其事必先利其器, 以前每次使用markdown的时候最麻烦的就是从剪贴板贴图,所以今天先对vscode进行配置, 使得vscode能够自动从剪贴板中保存图片到本地目录, 且自动生成markdown图片链接.","text":"最近开始回归github pages, 重新捡起VS CODE来写记录了. 工欲善其事必先利其器, 以前每次使用markdown的时候最麻烦的就是从剪贴板贴图,所以今天先对vscode进行配置, 使得vscode能够自动从剪贴板中保存图片到本地目录, 且自动生成markdown图片链接. 准备首先需要安装vscode, 版本的话应该没有限制.我这边使用的是1.49.0版本.安装完成之后可以按照自己的使用习惯修改样式. 安装贴图插件在左侧的拓展tab中搜索Markdown Paste, 安装第一个即可. 安装完成之后默认就可以通过ctrl + alt + v进行粘贴图片. 需要注意的是只支持markdown文件, 其他文件类型不生效. 配置自动保存路径由于我使用的是hexo, 文章中使用的图片需要在文件的同名目录下,为了方便我就直接修改默认保存路径为当前文件不带后缀的文件夹下 在左侧的拓展tab页中要找刚才安装好的Markdown Paste插件, 点击左下角的配置按钮,选择extension settings. 配置Markdown Past:Path, 设置值为./${fileBasenameNoExtension}/,意为当前文件不带后缀的文件夹下 测试使用任意工具截图后保存到剪贴板中, 在vs code中编辑markdown文件时使用ctrl + alt + v,顶部将会弹出文件保存框, 默认会使用当前时间作为文件名,可以任意修改.","categories":[],"tags":[]},{"title":"Maven","slug":"mvn","date":"2020-10-10T16:13:45.000Z","updated":"2020-10-22T12:07:25.560Z","comments":true,"path":"2020/10/10/mvn/","link":"","permalink":"https://elliot-yang.github.io/2020/10/10/mvn/","excerpt":"Maven是java开发中常见的编译工具, 拥有很多强大的plugin. 安装部分","text":"Maven是java开发中常见的编译工具, 拥有很多强大的plugin. 安装部分 准备maven 下载：wget http://mirror.bit.edu.cn/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz 解压：tar -zxvf apache-maven-3.3.9-bin.tar.gz 移动到/usr/local：# mv apache-maven-3.3.9 /usr/local/maven3 添加环境变量：vim /etc/profile，在最后添加如下两行 12export MAVEN_HOME=/usr/local/maven3export PATH=$MAVEN_HOME/bin:$PATH 保存退出后输入命令使配置生效：source /etc/profile 检验是否安装成功：mvn -v 编译打包 基础 执行命令mvn clean package即可清理工作空间(target目录),并重新在target目录编译打包工程 跳过测试打包 若是在工程中有单元测试用例,maven在编译打包时会自动执行,若需跳过只需要添加参数maven.test.skip为true即可 mvn clean package -Dmaven.test.skip=true 部署 基础 执行命令mvn deploy即可, 需要提前在maven的setting.xml中配置好仓库的用户名和密码 存在父子模块的情况 父子模块全都要发布, 直接在父目录执行命令mvn deploy即可 只发布父模块, 在父目录执行命令时添加参数-N即可: mvn delpoy -N","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://elliot-yang.github.io/tags/java/"}]},{"title":"文本编辑器Vi内部命令","slug":"vi","date":"2020-03-26T15:39:14.000Z","updated":"2020-10-22T12:07:25.560Z","comments":true,"path":"2020/03/26/vi/","link":"","permalink":"https://elliot-yang.github.io/2020/03/26/vi/","excerpt":"经常碰到需要在Linux服务器上修改文件或者查找日志的情况, 没有图形界面的情况下只好使用vi,使用的过程中发现了很多vi强大的功能点.","text":"经常碰到需要在Linux服务器上修改文件或者查找日志的情况, 没有图形界面的情况下只好使用vi,使用的过程中发现了很多vi强大的功能点. 基础用法使用命令vi xxx.config打开文件, 按下i开始插入模式编辑,a开始追加模式编辑,按下ESC退出编辑. 查找内容首先需要退出编辑模式,输入/2020-03-26回车之后就会自动找寻2020-03-26内容,找到内容后继续操作n(下一个结果)\\N(前一个结果) 替换内容语法为: :[addr]s/源字符串/目的字符串/[option] 字符串支持正则表达式 [addr]: 代表检索范围 “1, 100” 代表1到100行 “%” 代表全文 “., $” 代表当前行到文件结束 [option]: 代表操作类型 默认: 对每行第一个匹配字符串进行替换 g: 全局 c: 表示进行确认 p: 替换结果逐行显示(Ctrl + L恢复编辑)首先需要退出编辑模式,输入:%s/date/newDate/g,表示将全文的date字符串替换为newDate 总结vi能满足大部分的普通编辑需求,相对来说应该是命令行模式比较好用的编辑器,另外更详细的文档可以参照vi详解","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://elliot-yang.github.io/tags/linux/"}]},{"title":"数据库隔离中的脏读、不可重复读、幻读","slug":"db-island","date":"2020-03-08T11:50:58.000Z","updated":"2020-10-22T12:07:25.560Z","comments":true,"path":"2020/03/08/db-island/","link":"","permalink":"https://elliot-yang.github.io/2020/03/08/db-island/","excerpt":"注意： 以下的修改指insert、update和delete，提交包括正常的commit操作以及rollback回滚操作。","text":"注意： 以下的修改指insert、update和delete，提交包括正常的commit操作以及rollback回滚操作。 传统关系型数据库在事务上有四种隔离策略： Serializable： 串行，即简单将所有事务串行的执行，这种方式完全遵循ACID原则，确保每个事务之间完全隔离，但消耗大效率低，一般不会使用该种隔离。 Repeatable Read： 重复读，确保一个事务不会修改另一个事务已读取的记录，在MySQL数据库中默认使用该隔离策略。 Read Committed： 提交读，确保一个事务不会读取到另一个事务已修改但未提交的数据，大部分数据默认采用该种隔离。 Read Uncommitted： 未提交读，一个事务已修改但未提交的数据也能被其他事务读取，最为宽松的隔离策略。 数据库事务中又有三种最易发生的问题： 脏读：顾名思义，即是读取到了脏数据，脏数据指在其他事务中进行了修改但未提交的记录。 不可重复读：不可重复读是指在一个事务A中，进行了数据读取之后，其他事务对这些数据进行了修改，导致事务A在后一次的数据读取中发现两次读取到的数据不匹配。 幻读：幻读指一个事务A通过条件查询到n条数据之后其他事务对数据进行了修改，导致事务A在下一次使用相同条件查询时获取到的数据条数和n不相同。 隔离级别及三种问题之间的关系 脏读 不可重复读 幻读 Serializable × × × Repeatable Read × × √ Read Committed × √ √ Read Uncommitted √ √ √ √代表可能发生， ×代表不会发生","categories":[],"tags":[]},{"title":"字节数组合并","slug":"byteArrayCombine","date":"2019-04-20T14:59:02.000Z","updated":"2020-10-22T12:07:25.556Z","comments":true,"path":"2019/04/20/byteArrayCombine/","link":"","permalink":"https://elliot-yang.github.io/2019/04/20/byteArrayCombine/","excerpt":"最近碰到有同事处理字符数组合并时写法很麻烦, 所以帮着改了下,比之前的写法稍微简单一些.","text":"最近碰到有同事处理字符数组合并时写法很麻烦, 所以帮着改了下,比之前的写法稍微简单一些. 原始写法 public static byte[] bytesCombine(byte[] a, byte[] b){ int newLength = a.length+b.length; byte[] result = new byte[newLength]; for (int i = 0; i &lt; a.length; i++) { result[i] = a[i]; } for (int i = 0; i &lt; b.length; i++) { result[a.length + i] = b[i]; } return result; } 改进写法for循环来复制数组的话, 写法略微有些累赘,所以稍微改进一下: public static byte[] bytesCombine(byte[] a, byte[] b){ int newLength = a.length+b.length; byte[] result = new byte[newLength]; System.arraycopy(a, 0, result, 0, a.length); System.arraycopy(b, 0, result, a.length , b.length); return result; } 拓展写法 虽然这个方法现在的确能处理两个字节数组合并, 但是若是遇到多个字节数组合并时还得多次调用,考虑改成可变长度参数形式 public static byte[] bytesCombine(byte[]... bytes) { if (bytes.length == 1) { return bytes[0]; } int newLength = 0; for (byte[] array : bytes) { newLength += array.length; } byte[] result = new byte[newLength]; int currentLength = 0; for (byte[] array : bytes) { System.arraycopy(array, 0, result, currentLength, array.length); currentLength += array.length; } return result; } 循环了两次字符数组, 可以改用字节流来进行处理 public static byte[] bytesCombine(byte[]... bytes) { if (bytes.length == 1) { return bytes[0]; } try(ByteArrayOutputStream outputStream = new ByteArrayOutputStream()){ for (byte[] array : bytes) { outputStream.write(array, 0, array.length); } return outputStream.toByteArray(); }catch (IOException e){ // do something } return null; } 总结虽然只是简单的字节数组合并, 可以看到还是有很多不同的写法, 对应的效率也不同(以后可能会做一个性能测试). 最后拓展的写法中, 使用字节流处理的代码结构更加清晰, 但是需要对异常进行处理, 而不使用字节流的话会多一次循环过程, 所以大家在使用的时候可以根据个人喜好、具体场景等自由选择.补充一个性能测试图： 可以看到使用System.arraycopy比使用流效率更好, 在测试结果中， 使用流进行字节数组合并的效率甚至不及普通的for循环处理。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://elliot-yang.github.io/tags/java/"}]},{"title":"linux常用命令","slug":"linux-basic","date":"2019-03-18T15:12:58.000Z","updated":"2020-10-22T12:07:25.560Z","comments":true,"path":"2019/03/18/linux-basic/","link":"","permalink":"https://elliot-yang.github.io/2019/03/18/linux-basic/","excerpt":"经常在Linux服务器上操作，记录一些常用的以及不常用的命令方便以后查阅。","text":"经常在Linux服务器上操作，记录一些常用的以及不常用的命令方便以后查阅。 常用命令查找命令find# 查找当前目录下所有后缀为.log的文件 find . -name \"*.log\" 查看文件列表ls# 列表形式显示文件 ls -al # 效果同上 ll # 列表形式显示所有文件，包括隐藏文件 ls -al # 列表显示文件，并筛选出包含 xx 的文件 ll | grep xx 输出文件内容cat,tail# 直接输出文件全部内容 cat xxx.log # 输出文件末位的几行内容 tail xxx.log # 输出文件末尾几行内容并且持续更新,一般用来看日志 tail -f xxx.log 编辑文件vivi xxx.config 显示当前路径pwd切换用户su# 切换到web用户，但是环境变量不会重载 su web # 切换到web用户，并且环境变量也重载 su - web 复制文件cp# 复制单个文件 cp source target # 复制文件夹以及内部所有文件 cp -r sourceDir targetDir 磁盘使用情况du# 显示各个挂载点的磁盘占用情况,-h human readable以人类可读方式展示 du -h # 显示某个目录磁盘占用情况 du -sh xxxDir 服务器之间复制文件scp# 复制到远程服务器的/path目录下, -p保留源文件的修改时间和访问权限 scp -p xxxFile user@host:/path/xxxFile 解压缩unzip,tar# 直接解压zip文件 unzip xxx.zip # 解压zip文件到指定目录 unzip xxx.zip -d /path/xxx # 解压tar tar -xvf xxx.tar # 解压tar.gz, 带有gzip属性的压缩包 tar -zxvf xxx.tar.gz # 解压tar.bz2, 带有compress属性的压缩包 tar -jxvf xxx.tar.bz2 压缩zip,tar# 压缩当前目录下所有文件到xxx.zip, -r 表示递归所有子目录 zip -r xxx.zip # 压缩xxx目录到当前目录的zip文件中 zip -r xxx.zip /path/xxx # 压缩tar tar -czvf xxx.tar xxx 查找文件内容sed# 找出xxx.log中包含2020-03-26的内容并打印到控制台, 可以结合重定向`&gt;`命令输出到文件中方便查看日志 sed -n '/2020-03-26/p' xxx.log # 找出从2020-03-20到2020-03-26的内容 sed -n '/2020-03-20/,/2020-03-26/p' xxx.log 现在用到的命令也没有很多，后续还会继续补充。 总结Linux命令虽然比较复杂，但是常用的不多，有些命令用的较少但功能也比较强大，还是平时需要多使用才能记住。更多的命令详解可以参照linux命令详解","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://elliot-yang.github.io/tags/linux/"}]},{"title":"redis基础","slug":"redis","date":"2018-06-12T22:29:05.000Z","updated":"2020-10-22T12:07:25.560Z","comments":true,"path":"2018/06/12/redis/","link":"","permalink":"https://elliot-yang.github.io/2018/06/12/redis/","excerpt":"安装部分","text":"安装部分 环境：Ubuntu 16.04 LTS 先从redis官网上下载redis的源码得到 redis-3.2.8.tar.gz 使用命令解压文件到当前用户的software目录下（目录按照个人习惯定） 1tar -zxvf redis-3.2.8.tar.gz -C ~/software/ 使用make命令 12cd ~/software/redis-3.2.8make make完成之后，可执行文件就在src目录下了(可以选择单独将几个redis-*开头的可执行文件复制到单独的目录使用) 12345cd src # 这样是直接启动redis服务器，使用默认配置./redis-server# 或者使用指定配置文件的方式启动./redis-server ~/software/redis-3.2.8/redis.conf 修改配置文件，redis自带的redis.conf默认是只允许本机访问的，如果需要别的机器访问的话是需要修改一下配置的 启动vi编辑器修改配置文件 1vi ~/software/redis-3.2.8/redis.conf 找到下面这句，这是将redis配置绑定在本机 1bind 127.0.0.1 为了方便，我们直接将这句注释掉,这样就是所有的主机都可以访问redis,修改为下面这样 1# bind 127.0.0.1 不过为了安全着想，最好设置固定的访问地址，不然部署在公网上的redis没有密码的话是很容易被攻击的 设置为自动启动 先打开解压缩后的目录编辑utils/redis_init_scrip文件，修改文件顶部的几个配置，指定对应的路径（pid文件在运行过redis后会自动生成在/var/run/目录下 将utils/redis_init_scrip文件复制到/etc/init.d/目录下命名为redis，并授权chmod +x 开启服务自启，执行命令chkconfig redis on 添加到开机自启，执行命令chkconfig –add redis 使用部分首先需要启动redis自带的客户端,同样在src目录中已经包含了 1234cd ~/software/redis-3.2.8/src./redis-cli# 若是访问远程redis-server的话需要指定host和端口./redis-cli -h &lt;host&gt; -p &lt;port&gt; 使用上面的命令就能进入redis客户端了。 string类型的一些简单操作 1234567891011121314151617# 添加一个键为name，值为yang的string类型数据set name 'yang'# 获取键为name的string类型值get name# 设置键值，并获取旧值,单双引号注意配对getset name \"yang's blog\"# 设置键为a的值自增长1，和a=a+1类似，但为atomic操作，不会出现并发问题set a 1incr a# 设置值自减1decr a# 追加值到指定键的值append a 2 --&gt; 这时候a的值应该为12# 设置键值的过期时间,设置a过期时间为100ssetex a 100 s# 获取剩余时间，值得注意的是：没有设置过期时间的键得到的值为-1，已过期的键得到的值为-2，其余的显示实际剩余时间ttl a list类型的基本操作list的操作一般都分为左右两种，即list头部操作为L，list尾部操作为R，另外list是有序的数据结构 12345678910111213141516# 向list中添加一个值rpush lst 1# 添加多个值rpush lst 2 3 4# 获取指定索引位置的值lindex lst 0# 从list尾部获取一个值，并从list中删除rpop lst# 获取list指定范围索引的值,索引从0开始，可以使用负数，代表从尾部开始的第几个数lrange lst 0 -1# 获取list的长度，即list元素的个数llen lst# 设置指定索引位置的值,设置lst的0索引上的值为111lset lst 0 111# 去除指定范围之外的值，下面这句可以去除list首尾各一个数据ltrim lst 1 -2 set类型的基本操作 1234567891011121314151617181920# 添加值 'yang'至s中sadd s 'yang'# 显示s所有成员smembers s# 判断obj是否包含于set集合s中sismember s obj# 显示s成员个数scard s# 取若干set集合的交集（每个set集合中都包含的才会显示）sinter s s1 s2# 取交集保存到指定集合targetsinterstore target s s1 s2# 取并集sunion s s1 s2# 取并集保存到指定集合targetsunionstore target s s1 s2# 差集sdiff s s1 s2# 取差集保存到指定集合sdiffstore target s s1 s2 哈希类型操作：类似于Java中的Map和Python中的Dict 123456789101112131415# 设置一个哈希值hset hsh name 'yang'hset hsh age 21# 获取指定哈希中指定字段的值hget hsh name# 获取哈希中所有的键hkeys hsh# 获取哈希中所有的值hvals hsh# 获取哈希中所有的键值hgetall hsh# 获取哈希中字段个数hlen hsh# 哈希中某字段自增长1，类似string中的incrhincrby hsh age","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"https://elliot-yang.github.io/tags/redis/"},{"name":"NoSQL","slug":"NoSQL","permalink":"https://elliot-yang.github.io/tags/NoSQL/"}]}]}