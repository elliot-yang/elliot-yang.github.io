{"meta":{"title":"Yang's Blog","subtitle":null,"description":null,"author":"Yang","url":"https://elliot-yang.github.io"},"pages":[{"title":"关于我","date":"2018-06-13T16:46:51.000Z","updated":"2020-03-08T03:52:53.411Z","comments":true,"path":"about/index.html","permalink":"https://elliot-yang.github.io/about/index.html","excerpt":"","text":"杨扬 男 / 1995年 所在地：上海 学历：本科（全日制） 手机：+86-15579151664 邮箱：elliot-yang@outlook.com 工作经历**信息 中台项目研发 项目简介：中台项目是为了方便APP调用老业务系统及新系统接口而产生的，主要是能够保证在业务系统内网隔离的情况下，APP能从外网访问业务系统的数据。 参与内容： 集成Oauth2以及JWT等认证方式 提供接口转发（一般是App请求到中台，然后中台访问业务系统），同时记录进出站日志。 提供接口请求及响应数据的转换功能 添加微信模块，支持对微信公众号进行菜单管理、客服消息发送、自动回复等。 信息 易项目研发 项目简介：易系统是为行业量身打造的业务系统，能够信息化整个业务流程，方便行业公司对内部业务数据的管理。 参与内容： RabbitMQ队列支持，可用于与其他系统进行数据交换。 合同文本生成功能，通过预设word模板（docx），可通过传递参数添加图片或文字水印、生成表格、动态添加表格行、生成段落内容、任意书签替换等。 通过MyBatis拦截器和正则表达式实现系统原有SQL，兼容MySQL和Oracle。 通过MyBatis拦截器实现敏感数据过滤器及白名单。 通过拦截器和LogBack完成日志按照用户及uri分配到不同日志文件。 通过拦截器完成对老系统的接口结果数据兼容。 支持服务端运行JavaScript代码，并支持调用Java代码以及获取spring托管的bean，实现服务端部分功能热部署。 数据动态修改，通过传递Map和tableName，自动解析当前数据库中对应表结构，可执行CRUD等操作。 其他业务相关功能模块。"}],"posts":[{"title":"数据库隔离中的脏读、不可重复读、幻读","slug":"db-island","date":"2020-03-08T11:50:58.000Z","updated":"2020-03-08T03:52:53.411Z","comments":true,"path":"2020/03/08/db-island/","link":"","permalink":"https://elliot-yang.github.io/2020/03/08/db-island/","excerpt":"注意： 以下的修改指insert、update和delete，提交包括正常的commit操作以及rollback回滚操作。","text":"注意： 以下的修改指insert、update和delete，提交包括正常的commit操作以及rollback回滚操作。 传统关系型数据库在事务上有四种隔离策略： Serializable： 串行，即简单将所有事务串行的执行，这种方式完全遵循ACID原则，确保每个事务之间完全隔离，但消耗大效率低，一般不会使用该种隔离。 Repeatable Read： 重复读，确保一个事务不会修改另一个事务已读取的记录，在MySQL数据库中默认使用该隔离策略。 Read Committed： 提交读，确保一个事务不会读取到另一个事务已修改但未提交的数据，大部分数据默认采用该种隔离。 Read Uncommitted： 未提交读，一个事务已修改但未提交的数据也能被其他事务读取，最为宽松的隔离策略。 数据库事务中又有三种最易发生的问题： 脏读：顾名思义，即是读取到了脏数据，脏数据指在其他事务中进行了修改但未提交的记录。 不可重复读：不可重复读是指在一个事务A中，进行了数据读取之后，其他事务对这些数据进行了修改，导致事务A在后一次的数据读取中发现两次读取到的数据不匹配。 幻读：幻读指一个事务A通过条件查询到n条数据之后其他事务对数据进行了修改，导致事务A在下一次使用相同条件查询时获取到的数据条数和n不相同。 隔离级别及三种问题之间的关系 脏读 不可重复读 幻读 Serializable × × × Repeatable Read × × √ Read Committed × √ √ Read Uncommitted √ √ √ √代表可能发生， ×代表不会发生","categories":[],"tags":[]},{"title":"redis基础","slug":"redis","date":"2018-06-12T22:29:05.000Z","updated":"2020-03-08T03:52:53.411Z","comments":true,"path":"2018/06/12/redis/","link":"","permalink":"https://elliot-yang.github.io/2018/06/12/redis/","excerpt":"安装部分","text":"安装部分 环境：Ubuntu 16.04 LTS 先从redis官网上下载redis的源码得到 redis-3.2.8.tar.gz 使用命令解压文件到当前用户的software目录下（目录按照个人习惯定） 1tar -zxvf redis-3.2.8.tar.gz -C ~/software/ 使用make命令 12cd ~/software/redis-3.2.8make make完成之后，可执行文件就在src目录下了(可以选择单独将几个redis-*开头的可执行文件复制到单独的目录使用) 12345cd src # 这样是直接启动redis服务器，使用默认配置./redis-server# 或者使用指定配置文件的方式启动./redis-server ~/software/redis-3.2.8/redis.conf 修改配置文件，redis自带的redis.conf默认是只允许本机访问的，如果需要别的机器访问的话是需要修改一下配置的 启动vi编辑器修改配置文件 1vi ~/software/redis-3.2.8/redis.conf 找到下面这句，这是将redis配置绑定在本机 1bind 127.0.0.1 为了方便，我们直接将这句注释掉,这样就是所有的主机都可以访问redis,修改为下面这样 1# bind 127.0.0.1 不过为了安全着想，最好设置固定的访问地址，不然部署在公网上的redis没有密码的话是很容易被攻击的 设置为自动启动 先打开解压缩后的目录编辑utils/redis_init_scrip文件，修改文件顶部的几个配置，指定对应的路径（pid文件在运行过redis后会自动生成在/var/run/目录下 将utils/redis_init_scrip文件复制到/etc/init.d/目录下命名为redis，并授权chmod +x 开启服务自启，执行命令chkconfig redis on 添加到开机自启，执行命令chkconfig –add redis 使用部分首先需要启动redis自带的客户端,同样在src目录中已经包含了 1234cd ~/software/redis-3.2.8/src./redis-cli# 若是访问远程redis-server的话需要指定host和端口./redis-cli -h &lt;host&gt; -p &lt;port&gt; 使用上面的命令就能进入redis客户端了。 string类型的一些简单操作 1234567891011121314151617# 添加一个键为name，值为yang的string类型数据set name 'yang'# 获取键为name的string类型值get name# 设置键值，并获取旧值,单双引号注意配对getset name \"yang's blog\"# 设置键为a的值自增长1，和a=a+1类似，但为atomic操作，不会出现并发问题set a 1incr a# 设置值自减1decr a# 追加值到指定键的值append a 2 --&gt; 这时候a的值应该为12# 设置键值的过期时间,设置a过期时间为100ssetex a 100 s# 获取剩余时间，值得注意的是：没有设置过期时间的键得到的值为-1，已过期的键得到的值为-2，其余的显示实际剩余时间ttl a list类型的基本操作list的操作一般都分为左右两种，即list头部操作为L，list尾部操作为R，另外list是有序的数据结构 12345678910111213141516# 向list中添加一个值rpush lst 1# 添加多个值rpush lst 2 3 4# 获取指定索引位置的值lindex lst 0# 从list尾部获取一个值，并从list中删除rpop lst# 获取list指定范围索引的值,索引从0开始，可以使用负数，代表从尾部开始的第几个数lrange lst 0 -1# 获取list的长度，即list元素的个数llen lst# 设置指定索引位置的值,设置lst的0索引上的值为111lset lst 0 111# 去除指定范围之外的值，下面这句可以去除list首尾各一个数据ltrim lst 1 -2 set类型的基本操作 1234567891011121314151617181920# 添加值 'yang'至s中sadd s 'yang'# 显示s所有成员smembers s# 判断obj是否包含于set集合s中sismember s obj# 显示s成员个数scard s# 取若干set集合的交集（每个set集合中都包含的才会显示）sinter s s1 s2# 取交集保存到指定集合targetsinterstore target s s1 s2# 取并集sunion s s1 s2# 取并集保存到指定集合targetsunionstore target s s1 s2# 差集sdiff s s1 s2# 取差集保存到指定集合sdiffstore target s s1 s2 哈希类型操作：类似于Java中的Map和Python中的Dict 123456789101112131415# 设置一个哈希值hset hsh name 'yang'hset hsh age 21# 获取指定哈希中指定字段的值hget hsh name# 获取哈希中所有的键hkeys hsh# 获取哈希中所有的值hvals hsh# 获取哈希中所有的键值hgetall hsh# 获取哈希中字段个数hlen hsh# 哈希中某字段自增长1，类似string中的incrhincrby hsh age","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"https://elliot-yang.github.io/tags/redis/"},{"name":"NoSQL","slug":"NoSQL","permalink":"https://elliot-yang.github.io/tags/NoSQL/"}]}]}